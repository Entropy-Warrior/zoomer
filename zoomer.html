<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Zoomer's Sliders - Improved with Hide/Show UI</title>
<style>
  html, body {
    margin: 0; 
    padding: 0; 
    height: 100%; 
    overflow: hidden;
  }
  #openseadragon {
    width: 100%;
    height: 100%;
    position: relative;
    background: #333;
  }
  .selection-rectangle {
    position: absolute;
    border: 2px dashed #00ff00;
    pointer-events: none;
    display: none;
    z-index: 9999;
  }
  .instructions {
    position: absolute;
    font-family: sans-serif;
    z-index: 9999;
    display: inline-block;
  }
  .overview-instructions {
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: #fff;
    font-size: 14px;
    padding: 8px 12px;
    border-radius: 4px;
    max-width: 300px;
  }
  .presentation-instructions {
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.3);
    color: #ccc;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 4px;
    max-width: 600px;
    white-space: nowrap;
  }
  #overlayCanvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events:none;
    z-index: 5000;
  }

  /* Toolbar styling */
  .toolbar {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 9999;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 4px;
    font-size: 14px;
    color: #fff;
  }
  .toolbar button, .toolbar input[type="file"] {
    display: block;
    margin-bottom: 10px;
    background: #444;
    color: #fff;
    border: 1px solid #666;
    padding: 5px 10px;
    cursor: pointer;
  }
  .toolbar button:hover {
    background: #555;
  }

  /* Toggle UI button always visible */
  #toggleUIBtn {
    position: absolute; 
    top: 10px; 
    left: 10px; 
    z-index: 10000; 
    background: #888; 
    color: #fff; 
    border: none; 
    padding: 5px; 
    cursor: pointer;
    border-radius: 4px;
  }
  #toggleUIBtn:hover {
    background: #777;
  }
</style>
<script src="openseadragon.min.js"></script>
</head>
<body>
<div id="openseadragon"></div>
<div class="selection-rectangle" id="selectionRect"></div>
<div class="instructions overview-instructions" id="instructions">
  <strong>Instructions :</strong><br>
  - Drag to select a region (monitor ratio)<br>
  - Click 'Finalize Regions' when done<br>
  - After finalizing, click 'Enter Presentation' to start<br>
  - Use 'Save Settings' and 'Load Settings' for preservation<br>
  - 'Clear All' to reset<br>
  Zoomer's Sliders by lin.wang@wangscience.com
</div>
<canvas id="overlayCanvas"></canvas>

<!-- Toolbar for UI-based controls -->
<div class="toolbar" id="toolbar">
  <!-- Image Loader -->
  <label>Load Image:</label>
  <input type="file" id="imageLoader" accept="image/*" />

  <!-- Settings Loader -->
  <label>Load Settings (JSON):</label>
  <input type="file" id="settingsLoader" accept=".json" />

  <!-- Buttons for actions -->
  <button id="finalizeBtn" disabled>Finalize Regions</button>
  <button id="presentationBtn" disabled>Enter Presentation</button>
  <button id="saveBtn" disabled>Save Settings</button>
  <button id="clearBtn" disabled>Clear All</button>
</div>

<!-- Always visible toggle button for UI -->
<button id="toggleUIBtn">Hide UI</button>

<script>
// Global variables
var viewer, tiledImage;
var selectionRectElement = document.getElementById('selectionRect');
var instructions = document.getElementById('instructions');
var overlayCanvas = document.getElementById('overlayCanvas');
var overlayCtx = overlayCanvas.getContext('2d');
var toolbar = document.getElementById('toolbar');
var toggleUIBtn = document.getElementById('toggleUIBtn');

var editMode = true;         
var views = [];              
var startPoint = null;       
var ended = false;           
var presentationMode = false;
var currentViewIndex = 0;
var monitorAspectRatio = window.screen.width / window.screen.height;

var finalizeBtn = document.getElementById('finalizeBtn');
var presentationBtn = document.getElementById('presentationBtn');
var saveBtn = document.getElementById('saveBtn');
var clearBtn = document.getElementById('clearBtn');
var imageLoader = document.getElementById('imageLoader');
var settingsLoader = document.getElementById('settingsLoader');

// Initially, no image loaded, disable most buttons
finalizeBtn.disabled = true;
presentationBtn.disabled = true;
saveBtn.disabled = true;
clearBtn.disabled = true;

// Handle image loading
imageLoader.addEventListener('change', function(e) {
  var file = e.target.files[0];
  if (file) {
    var url = URL.createObjectURL(file);
    initializeViewer(url);
    finalizeBtn.disabled = false;
    clearBtn.disabled = false;
  }
});

// Handle settings loading
settingsLoader.addEventListener('change', function(e) {
  var file = e.target.files[0];
  if (file) {
    var reader = new FileReader();
    reader.onload = function(ev) {
      var json = JSON.parse(ev.target.result);
      // Assume json is { "views": [ {x,y,w,h}, ... ] }
      views = json.views || [];
      ended = true;
      editMode = false;
      drawAll();
      if (views.length > 0) {
        presentationBtn.disabled = false;
        saveBtn.disabled = false;
      }
    };
    reader.readAsText(file);
  }
});

// Setup the viewer once an image is selected
function initializeViewer(imageUrl) {
  viewer = OpenSeadragon({
    id: "openseadragon",
    prefixUrl: "https://openseadragon.github.io/openseadragon/images/",
    tileSources: {
      type: 'image',
      url: imageUrl
    },
    showNavigationControl: false,
    animationTime: 1.0,
    springStiffness: 5.0,
    gestureSettingsMouse: { 
      scrollToZoom: false, 
      clickToZoom: false, 
      dblClickToZoom: false, 
      dragToPan: false
    }
  });

  viewer.addHandler('open', function() {
    tiledImage = viewer.world.getItemAt(0);
    lockViewer(true);
    setupSelectionHandlers();
    resizeOverlay();
  });

  window.addEventListener('resize', resizeOverlay);

  document.addEventListener('fullscreenchange', function() {
    if (!document.fullscreenElement && presentationMode) {
      presentationMode = false;
      viewer.viewport.goHome(true);
      lockViewer(true);
      showOverviewInstructions();
      viewer.addOnceHandler('animation-finish', function(){
        resizeOverlay(); 
        drawAll();  
      });
    }
  });
}

// Toolbar Buttons
finalizeBtn.addEventListener('click', endEditing);
presentationBtn.addEventListener('click', enterPowerpointMode);
saveBtn.addEventListener('click', saveSettings);
clearBtn.addEventListener('click', resetAll);

// Toggle UI button
var uiVisible = true;
toggleUIBtn.addEventListener('click', function() {
  uiVisible = !uiVisible;
  toolbar.style.display = uiVisible ? 'block' : 'none';
  instructions.style.display = uiVisible ? 'block' : 'none';
  toggleUIBtn.textContent = uiVisible ? 'Hide UI' : 'Show UI';
});

viewer?.addHandler('canvas-click', function(event) {
  if (presentationMode) {
    event.preventDefaultAction = true;
    nextRegion();
  }
});

// Ctrl+C to clear as a fallback
document.addEventListener('keydown', function(e) {
  if (e.code === 'KeyC' && e.ctrlKey) {
    resetAll();
  }
  if (presentationMode && views.length > 0) {
    if (e.key === ' ' || e.key === 'ArrowRight') {
      nextRegion();
    } else if (e.key === 'ArrowLeft') {
      prevRegion();
    } else if (e.key === 'Escape') {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        presentationMode = false;
        viewer.viewport.goHome(true);
        lockViewer(true);
        showOverviewInstructions();
        drawAll();
      }
    }
  }
});

function setupSelectionHandlers() {
  viewer.innerTracker.moveHandler = function(event) {
    if (editMode && startPoint) {
      var rect = calculateRectWithAspectRatio(startPoint, event.position);
      drawSelectionRect(rect);
    }
  };

  viewer.innerTracker.pressHandler = function(event) {
    if (editMode) {
      startPoint = event.position; 
    }
  };

  viewer.innerTracker.releaseHandler = function(event) {
    if (editMode && startPoint) {
      var rect = calculateRectWithAspectRatio(startPoint, event.position);
      if (rect.width > 5 && rect.height > 5) {
        var imageRect = screenRectToImageRect(rect, tiledImage, viewer);
        views.push({x: imageRect.x, y: imageRect.y, w: imageRect.w, h: imageRect.h});
        selectionRectElement.style.display = 'none';
        startPoint = null;
        drawAll();
      } else {
        selectionRectElement.style.display = 'none';
        startPoint = null; 
      }
    }
  };
}

function lockViewer(lock) {
  viewer.gestureSettingsMouse.dragToPan = !lock;
  viewer.gestureSettingsMouse.scrollToZoom = !lock;
  viewer.gestureSettingsMouse.clickToZoom = !lock;
  viewer.gestureSettingsMouse.dblClickToZoom = !lock;
}

function lockViewerForPresentation() {
  viewer.gestureSettingsMouse.dragToPan = false;
  viewer.gestureSettingsMouse.scrollToZoom = false;
  viewer.gestureSettingsMouse.clickToZoom = false;
  viewer.gestureSettingsMouse.dblClickToZoom = false;
}

function getScreenAspectRatio() {
  return monitorAspectRatio;
}

function calculateRectWithAspectRatio(p1, p2) {
  var aspect = getScreenAspectRatio();
  var x = Math.min(p1.x, p2.x);
  var y = Math.min(p1.y, p2.y);
  var width = Math.abs(p1.x - p2.x);
  var height = Math.abs(p1.y - p2.y);

  var currentRatio = width / height;
  if (currentRatio > aspect) {
    height = width / aspect;
    if (p2.y < p1.y) {
      y = p1.y - height;
    }
  } else {
    width = height * aspect;
    if (p2.x < p1.x) {
      x = p1.x - width;
    }
  }

  return {x: x, y: y, width: width, height: height};
}

function drawSelectionRect(rect) {
  selectionRectElement.style.left = rect.x + 'px';
  selectionRectElement.style.top = rect.y + 'px';
  selectionRectElement.style.width = rect.width + 'px';
  selectionRectElement.style.height = rect.height + 'px';
  selectionRectElement.style.display = 'block';
}

function screenRectToImageRect(screenRect, tiledImage, viewer) {
  var topLeftViewport = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(screenRect.x, screenRect.y), true);
  var bottomRightViewport = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(screenRect.x + screenRect.width, screenRect.y + screenRect.height), true);

  var topLeftImage = tiledImage.viewportToImageCoordinates(topLeftViewport);
  var bottomRightImage = tiledImage.viewportToImageCoordinates(bottomRightViewport);

  return {
    x: topLeftImage.x,
    y: topLeftImage.y,
    w: bottomRightImage.x - topLeftImage.x,
    h: bottomRightImage.y - topLeftImage.y
  };
}

function endEditing() {
  editMode = false;
  ended = true;
  presentationBtn.disabled = (views.length === 0);
  saveBtn.disabled = (views.length === 0);
  drawAll();
  showOverviewInstructions();
}

function drawAll() {
  if (!overlayCtx) return;
  overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  if (!presentationMode && ended) {
    drawConnectingLine();
    eraseLineInsideRectangles();
    drawRectangles();
  } else if (!presentationMode && !ended) {
    drawRectangles();
  }
}

function drawConnectingLine() {
  if (views.length < 2) return; 
  overlayCtx.save();
  overlayCtx.strokeStyle = "red";
  overlayCtx.lineWidth = 2;
  overlayCtx.beginPath();
  for (var i = 0; i < views.length; i++) {
    var center = imageRectCenterToScreen(views[i]);
    if (i === 0) {
      overlayCtx.moveTo(center.x, center.y);
    } else {
      overlayCtx.lineTo(center.x, center.y);
    }
  }
  overlayCtx.stroke();
  overlayCtx.restore();
}

function eraseLineInsideRectangles() {
  overlayCtx.save();
  overlayCtx.globalCompositeOperation = 'destination-out';
  for (var i = 0; i < views.length; i++) {
    var rectScreen = imageRectToScreenRect(views[i]);
    overlayCtx.fillRect(rectScreen.x, rectScreen.y, rectScreen.w, rectScreen.h);
  }
  overlayCtx.restore();
}

function drawRectangles() {
  overlayCtx.save();
  for (var i = 0; i < views.length; i++) {
    var v = views[i];
    var rectScreen = imageRectToScreenRect(v);

    overlayCtx.fillStyle = 'rgba(0, 255, 255, 0.2)'; 
    overlayCtx.fillRect(rectScreen.x, rectScreen.y, rectScreen.w, rectScreen.h);

    overlayCtx.strokeStyle = 'cyan';
    overlayCtx.lineWidth = 2;
    overlayCtx.strokeRect(rectScreen.x, rectScreen.y, rectScreen.w, rectScreen.h);

    var text = (i+1).toString();
    overlayCtx.font = 'bold 24px sans-serif';
    overlayCtx.lineWidth = 3;
    overlayCtx.strokeStyle = 'black';
    overlayCtx.strokeText(text, rectScreen.x + 10, rectScreen.y + 30);
    overlayCtx.fillStyle = 'yellow';
    overlayCtx.fillText(text, rectScreen.x + 10, rectScreen.y + 30);
  }
  overlayCtx.restore();
}

function imageRectToScreenRect(view) {
  var topLeft = tiledImage.imageToViewportCoordinates(new OpenSeadragon.Point(view.x, view.y));
  var bottomRight = tiledImage.imageToViewportCoordinates(new OpenSeadragon.Point(view.x+view.w, view.y+view.h));
  var topLeftPx = viewer.viewport.pixelFromPoint(topLeft, true);
  var bottomRightPx = viewer.viewport.pixelFromPoint(bottomRight, true);
  return {
    x: topLeftPx.x,
    y: topLeftPx.y,
    w: bottomRightPx.x - topLeftPx.x,
    h: bottomRightPx.y - topLeftPx.y
  };
}

function imageRectCenterToScreen(view) {
  var centerX = view.x + view.w/2;
  var centerY = view.y + view.h/2;
  var imageCenterPoint = new OpenSeadragon.Point(centerX, centerY);
  var viewportPoint = tiledImage.imageToViewportCoordinates(imageCenterPoint);
  var pixelPoint = viewer.viewport.pixelFromPoint(viewportPoint, true);
  return pixelPoint;
}

async function enterPowerpointMode() {
  if (!ended || views.length === 0) return; 
  presentationMode = true;
  if (!document.fullscreenElement) {
    try {
      await document.documentElement.requestFullscreen();
    } catch (err) {
      console.warn("Fullscreen request denied.", err);
    }
  }
  showPresentationInstructions();
  lockViewerForPresentation();
  overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  currentViewIndex = 0;
  showView(views[currentViewIndex]);
}

function showView(view) {
  var imageRect = new OpenSeadragon.Rect(view.x, view.y, view.w, view.h);
  var viewportRect = viewer.viewport.imageToViewportRectangle(imageRect);
  viewer.viewport.fitBounds(viewportRect, false);
}

function resizeOverlay() {
  if (!viewer) return;
  var container = viewer.canvas;
  overlayCanvas.width = container.clientWidth;
  overlayCanvas.height = container.clientHeight;
  drawAll();
}

function resetAll() {
  views = [];
  ended = false;
  editMode = true;
  presentationMode = false;
  presentationBtn.disabled = true;
  saveBtn.disabled = true;
  drawAll();
  viewer.viewport.goHome(true);
  showOverviewInstructionsInitial();
}

function showPresentationInstructions() {
  instructions.classList.remove('overview-instructions');
  instructions.classList.add('presentation-instructions');
  instructions.innerHTML = "Click or SPACE/→ next, ← prev, ESC exit, Ctrl+C clear<br><br>Zoomer's Sliders by lin.wang@wangscience.com";
}

function showOverviewInstructions() {
  instructions.classList.remove('presentation-instructions');
  instructions.classList.add('overview-instructions');
  instructions.innerHTML = "<strong>Overview mode:</strong><br>Click 'Enter Presentation' to enter presentation mode<br>Click 'Clear All' to reset<br>Zoomer's Sliders by lin.wang@wangscience.com";
}

function showOverviewInstructionsInitial() {
  instructions.classList.remove('presentation-instructions');
  instructions.classList.add('overview-instructions');
  instructions.innerHTML = "<strong>Instructions :</strong><br>- Drag to select a region (monitor ratio)<br>- Click 'Finalize Regions' when done<br>- After finalizing, click 'Enter Presentation' to start<br>- Use 'Save Settings' and 'Load Settings' for preservation<br>- 'Clear All' to reset<br>Zoomer's Sliders by lin.wang@wangscience.com";
}

function nextRegion() {
  currentViewIndex = (currentViewIndex + 1) % views.length;
  showView(views[currentViewIndex]);
}

function prevRegion() {
  currentViewIndex = (currentViewIndex - 1 + views.length) % views.length;
  showView(views[currentViewIndex]);
}

function saveSettings() {
  if (!ended || views.length === 0) return;
  var data = JSON.stringify({views: views}, null, 2);
  var blob = new Blob([data], {type: "application/json"});
  var url = URL.createObjectURL(blob);
  
  var a = document.createElement("a");
  a.href = url;
  a.download = "settings.json";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
